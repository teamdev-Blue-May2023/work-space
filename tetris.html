<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>テトリス</title>
  <style>
    body {
      background-image: url(https://sozaino.site/wp-content/uploads/2021/11/gameneon03.jpg);
      text-align: center;
    }

    #container {
      margin: 0 auto;
    }

    #startButton {
      font-size: 20px;
      border-radius: 15px;
      background-color: #b2d8d8;
    }
  </style>
</head>

<body onload="init()">
  <div id="container">
    <canvas id="cvs"></canvas>
  </div>
  <button id="startButton">Start Game</button>
  <div id="preview">
    <canvas id="pre"></canvas>
  </div>
  <script>
    // 落下スピード
    const speed = 500;
    //ブロック1マスの大きさ
    const blockSize = 30;
    //ボードサイズ
    const boardRow = 20;
    const boardCol = 10;
    //キャンバスの取得
    const cvs = document.getElementById("cvs");
    //2dコンテキストを取得
    const ctx = cvs.getContext("2d");
    //キャンバスサイズ
    const canvasW = blockSize * boardCol;
    const canvasH = blockSize * boardRow;
    cvs.width = canvasW;
    cvs.height = canvasH;
    //コンテナの設定
    const container = document.getElementById("container");
    container.style.width = canvasW + 'px';

    // tetの1辺の長さ
    const tetSize = 4;
    // ゲームオーバー状態を表す変数
    let isGameOver = false;


    //テトリミノの追加
    const tetTypes = [
      [], //配列のインデックス0は空としておく。
      [
        [0, 0, 0, 0],
        [0, 0, 1, 1],
        [0, 0, 1, 1],
        [0, 0, 0, 0],
      ],
      [
        [0, 0, 0, 0],
        [0, 0, 1, 0],
        [0, 1, 1, 1],
        [0, 0, 0, 0],
      ],
      [
        [0, 0, 0, 0],
        [0, 1, 1, 0],
        [0, 0, 1, 1],
        [0, 0, 0, 0],
      ],
      [
        [0, 0, 0, 0],
        [0, 0, 1, 1],
        [0, 1, 1, 0],
        [0, 0, 0, 0],
      ],
      [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0],
      ],
      [
        [0, 0, 0, 0],
        [0, 1, 1, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 0],
      ],
      [
        [0, 0, 0, 0],
        [0, 0, 0, 1],
        [0, 1, 1, 1],
        [0, 0, 0, 0],
      ],
    ];

    //テトリミノの配列に対する色設定
    const tetColors = [
      'rgba(250, 250, 250, 0.2)', // 0は空のため色もなし
      'rgba(255, 255, 0, 1)',
      'rgba(147, 112, 219, 1)',
      'rgba(220, 20, 60, 1)',
      'rgba(124, 252, 0, 1)',
      'rgba(0, 255, 255, 1)',
      'rgba(30, 144, 255, 1)',
      'rgba(255, 140, 0, 1)',
    ];

    let tet_idx = 4;
    let tet = tetTypes[tet_idx];

    //ボード本体
    const board = [];

    let offsetX = 0;
    let offsetY = 0;

    // タイマーID
    let timerId = NaN;

    //描画処理
    const draw = () => {
      //塗りに黒を設定
      ctx.fillStyle = '#000';
      //キャンバスを塗りつぶす
      ctx.fillRect(0, 0, canvasW, canvasH);

      //ボードに存在しているブロックを塗る
      for (let y = 0; y < boardRow; y++) {
        for (let x = 0; x < boardCol; x++) {
          if (board[y][x]) {
            drawBlock(x, y, board[y][x]);
          }
        }
      }

      //着地点
      let plus=0;
      while(canMove(0, plus+1, tet)) plus++;

      // ゲームオーバーのチェック
      if (isGameOver) {
        ctx.font = '30px Arial';
        ctx.fillStyle = '#FF0000'; // 赤色でテキストを描画
        let text = 'Game Over';

        // measureText()でテキストの長さを取得
        let metrics = ctx.measureText(text);

        // textBaselineとtextAlignをセットしてテキストの描画位置を調整
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';

        ctx.fillText(text, canvasW / 2, canvasH / 2);

        return; // 描画ストップ
      }
      // 「移動」「回転」の動作確認のためにテトリミノのサンプルを一つ描画する
      for (let y = 0; y < tetSize; y++) {
        for (let x = 0; x < tetSize; x++) {
          if (tet[y][x]) {
            //着地点を描画
            drawBlock(offsetX + x, offsetY + y + plus, 0)
            //テトリミノを描画
            drawBlock(offsetX + x, offsetY + y, tet_idx);
          }
        }
      }
    }//end of draw

    //GameOverチェック関数
    const checkGameOver = () => {
      for (let x = 0; x < boardCol; x++) {
        if (board[1][x] !== 0) {
          return true;
        }
      }
      return false;
    };

    //回転
    const createRotateTet = () => {
      //新しいtetを作る
      let newTet = [];
      for (let y = 0; y < tetSize; y++) {
        newTet[y] = [];
        for (let x = 0; x < tetSize; x++) {
          //時計回りに90度回転させる
          newTet[y][x] = tet[tetSize - 1 - x][y];
        }
      }
      return newTet;
    };

    document.onkeydown = (e) => {
      e.preventDefault();
      switch (e.keyCode) {
        case 37: //左
          if (canMove(-1, 0)) offsetX--;
          break;
        case 39: //右
          if (canMove(1, 0)) offsetX++;
          break;
        case 40: //下
          if (canMove(0, 1)) offsetY++;
          break;
        case 38: //上で回転
          let newTet = createRotateTet();
          if (canMove(0, 0, newTet)) {
            tet = newTet;
          }
          break;
        case 32: //スペースキーで確定、即着地
          while (canMove(0, 1)) offsetY++;
          break;
      }
      draw();
    };

    // ブロックの描画
    const drawBlock = (x, y, tet_idx) => {
      let px = x * blockSize;
      let py = y * blockSize;
      //塗りを設定
      ctx.fillStyle = tetColors[tet_idx];
      ctx.fillRect(px, py, blockSize, blockSize);
      //線を設定
      ctx.strokeStyle = 'black';
      //線を描画
      ctx.strokeRect(px, py, blockSize, blockSize);
    };

    //移動の制限
    const canMove = (dx, dy, nowTet = tet) => {
      for (let y = 0; y < tetSize; y++) {
        for (let x = 0; x < tetSize; x++) {
          //その場所にブロックがあれば
          if (nowTet[y][x]) {
            //ボード座標に変換
            let nx = offsetX + x + dx;
            let ny = offsetY + y + dy;
            if (
              //調査する座標がボード外だったらできない
              ny < 0 ||
              nx < 0 ||
              ny >= boardRow ||
              nx >= boardCol ||
              //移動したいボード上の場所にすでに存在してたらできない
              board[ny][nx]
            ) {
              //移動できない
              return false;
            }
          }
        }
      }
      //移動できる
      return true;
    };

    //動きが止まったtetをボード座標に書き写す
    const fixTet = () => {
      for (let y = 0; y < tetSize; y++) {
        for (let x = 0; x < tetSize; x++) {
          if (tet[y][x]) {
            //ボードに書き込む
            board[offsetY + y][offsetX + x] = tet_idx;
          }
        }
      }
    };

    const clearLine = () => {
      //ボードの行を上から調査
      for (let y = 0; y < boardRow; y++) {
        //一列揃ってると仮定する(フラグ)
        let isLineOK = true;
        //列に0が入っていないか調査
        for (let x = 0; x < boardCol; x++) {
          if (board[y][x] === 0) {
            //0が入ってたのでフラグをfalse
            isLineOK = false;
            break;
          }
        }
        if (isLineOK) {//ここに来るということはその列が揃っていたことを意味する
          //その行から上に向かってfor文を動かす
          for (let ny = y; ny > 0; ny--) {
            for (let nx = 0; nx < boardCol; nx++) {
              //一列上の情報をコピーする
              board[ny][nx] = board[ny - 1][nx];
            }
          }
        }
      }
    };

    //繰り返し行われる落下処理
    const dropTet = () => {
      //下に行けたら
      if (canMove(0, 1)) {
        //下に行く
        offsetY++;
      } else {
        //行けなかったら固定する
        fixTet();
        //揃ったラインがあったら消す
        clearLine();
        if (checkGameOver()) {
          clearInterval(timerId);
          isGameOver = true; // ゲームオーバー状態にする
        }

        //抽選
        tet_idx = randomIdx();
        tet = tetTypes[tet_idx];
        //初期位置に戻す
        initStartPos();
        // ゲームオーバーチェックを移動
      }
      draw();
    };

    // 自動落下
    const initStartPos = () => {
      offsetX = boardCol / 2 - tetSize / 2;
      offsetY = 0;
    };

    //テトリミノのindexを抽選
    const randomIdx = () => {
      return Math.floor(Math.random() * (tetTypes.length - 1)) + 1;
    };

    //初期化処理
    const init = () => {
      //ボード(20*10を0埋め)
      for (let y = 0; y < boardRow; y++) {
        board[y] = [];
        for (let x = 0; x < boardCol; x++) {
          board[y][x] = 0;
        }
      }
      //最初のテトリミノを抽選
      tet_idx = randomIdx();
      tet = tetTypes[tet_idx];

      initStartPos();


      //繰り返し処理
      timerId = setInterval(dropTet, speed);

      //ゲーム開始の処理
      //Startボタンを押した時の処理
      window.onload = function () {
        document.getElementById("startButton").onclick = function () {
          init();
        };
      };

      draw();
    };
  </script>
</body>

</html>